<!-- TOC -->

- [斯坦纳树](#斯坦纳树)
- [虚树](#虚树)
- [树哈希](#树哈希)
- [支配树](#支配树)
- [prufer 序列 (待更新)](#prufer-序列-待更新)
- [LGV 引理 (待更新)](#lgv-引理-待更新)
- [二分图匹配问题](#二分图匹配问题)
    - [最长反链(待更新)](#最长反链待更新)
    - [霍尔定理](#霍尔定理)
    - [最小点覆盖方案构造](#最小点覆盖方案构造)
    - [HopcroftKarp算法(二分图匹配)](#hopcroftkarp算法二分图匹配)

<!-- /TOC -->


# 斯坦纳树
最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。

令$f[i][sta]$表示 $i$ 号节点，与关键节点节点的联通性为 $sta$ 时的最小代价，这里的 $sta$ 是一个二进制数，在它二进制下的每一位中，$0$ 表示不连通，$1$ 表示联通。
那么转移的时候会有两种情况
> 由子集转移而来: $f[i][sta] = min_{s \in sta} \{ cal(i, s, C_{sta}s)\}$

> 由不含该节点的状态转移而来: $f[i][s] = min\{ f[k][s] + val(i, k)\}$

总复杂度为 $O(n*3^k)$

``` plain
伪代码
枚举状态集 sta
{  
    
    枚举 sta 的子集 s 
    { 
        更新 f[1~n][sta]
    } 
    将 f[S][x]<inf 的x入队 
    spfa(S)
}
```

# 虚树

> 1.如果栈为空,或者栈中只有一个元素,那么显然应该:
    $stk[++top]=u;$
> 2.取 $lca=LCA(u,stk[top])$,如果 $lca=stk[top]$,则说明 $u$ 点应该接着 $stk[top]$ 点延长当前的树链.做操作: $stk[++top]=u;$
> 3.如果 $lca≠stk[top]$,则说明 $u$ 与 $stk[top]$ 分属 $lca$ 的两颗不同的子树,且包含 $stk[top]$ 的这颗子树应该已经构建完成了,我们需要做的是: 将 $lca$ 的包含 $stk[top]$ 子树的那部分退栈,并将这部分建边形成虚树.如果 $lca$ 不在栈(树链)中,那么要把 $lca$ 也加入栈中,保证虚树的结构不出现问题,随后将 $u$ 加入栈中,以表延长树链.

``` C++
//实现按照 dfn 顺序逐个将关键点插入形成一颗虚树
void insert(int u){
    if(top <= 1) {stk[++top] = u;return ;}
    int lca = LCA(u,stk[top]);
    if(lca == stk[top]) {stk[++top] = u;return ;}
    while(top > 1 && dfn[lca] <= stk[top-1]) {
        addedge(stk[top-1],stk[top]);
        --top;
    }
    if(lca != stk[top]) stk[++top] = lca;
    stk[++top] = u;
}
```

也可以先将关键点按 $dfs$ 序排序，得到序列 $a$ , 然后对 $a_i$ 和 $a_{i+1}$ 分别求 $lca$，再将所得到的点进行去重，然后按欧拉序用栈建树。	
> 如果只是单次建虚树，则可以考虑 $dfs$ 如果一个节点存在两颗子树有关键点，那么这个节点也是关键点。	

# 树哈希

Method I

Formula:
$$
f_{now} = size_{now} * \sum_{i} f_{son_{now, i}} * seed^{i-1}
$$

Note:
其中 $f_x$ 为以节点 $x$ 为根的子树对应的哈希值。特殊地，我们令叶子节点的哈希值为 $1$ 。

$size_x$ 表示以节点 $x$ 为根的子树大小。

$son_{x,i}$ 表示 $x$ 所有子节点以 $f$ 作为关键字排序后排名第 $i$ 的儿子。

$seed$ 为选定的一个合适的种子（最好是质数，对字符串 $hash$ 有了解的人一定不陌生）

上述哈希过程中，可以适当取模避免溢出或加快运行速度。

Method II
Formula
$$
f_{now} = \bigoplus_{i} f_{son_{now, i}} * seed + size_{son_{now, i}}
$$
Note:

其中 $f_x$ 为以节点 $x$ 为根的子树对应的哈希值。特殊地，我们令叶子节点的哈希值为 $1$ 。

$size_x$ 表示以节点 $x$ 为根的子树大小。

$son_{x,i}$ 表示 $x$ 的子节点(不用排序)

Hack:
由于异或的性质，如果一个节点下有多棵本质相同的子树，这种哈希值将无法分辨该种子树出现 $1, 3, 5, ....$ 次的情况。


Method III
Formula

$$
f_{now} = 1 + \sum_{i} f_{son_{now, i}} * prime(size_{son_{now, i}})
$$
其中 $f_x$ 为以节点 $x$ 为根的子树对应的哈希值。特殊地，我们令叶子节点的哈希值为 $1$ 。
$size_x$ 表示以节点 $x$ 为根的子树大小。
$son_{x,i}$ 表示 $x$ 的子节点(不用排序)
$prime(i)$ 表示第 $i$ 个素数
	
# 支配树
定义有向图的支配关系：对于一个固定的出发点 $s$, 如果从 $s$ 出发到达 $x$ 的所有路径都需要经过 $y$, 则称 $y$ 是 $x$ 的支配点，即 $y$ 支配 $x$。特别的，认为 $x$ 不是 $x$ 的支配点。
对有向图以 $r$ 作为根建 $dfs$ 树后，有如下性质:
1. 对于 $<x, y> \in S$ ，则如果 $x, y$ 在 $dfs$ 树上存在祖先关系，一定是 $dfn$ 小的点指向 $dfn$ 大的点，否则总是 $dfn$ 大的点指向 $dfn$ 小的点。
2. 如果 $u, v$ 是图中节点且 $dfn[u] < dfn[v]$，那么任意从 $u$ 到 $v$ 的路径必包含它们在 $dfs$ 树上的公共祖先(注意不一定是最近公共祖先)。
3. 任意一个点 $x$，它的支配点只可能是它的祖先节点: 如果不是祖先节点，那么可以直接沿着树边到达 $x$
4. 如果我们假设 $y$ 是 $x$ 的支配点中深度最大的，那么可以发现对于 $z \neq y$, $z$ 是 $x$ 的支配点当且仅当 $z$ 是 $y$ 的支配点。

为了求支配点，先定义半支配: 如果建好以 $r$ 为根的 $dfs$ 树后，对于任意一个点 $x$ , 从 $y$ 出发，只经过不是 $x$ 的祖先的节点就可以到达 $x$ (不包含 $x,y$ ), 则称 $y$ 是 $x$ 的半支配点，即 $y$ 半支配 $x$。记 $idom(x)$ 为 $x$ 的深度最小的支配点。

半支配点有如下性质 :
1. $x$ 的深度最小的半支配点一定是 $x$ 的祖先: 因为假设 $x$ 的深度最小的半支配点 $y$ 不是 $x$ 的祖先，那么可以沿着树边反向一直走到 $x$ 的某个祖先节点上。
2. 如果 $y$ 是 $x$ 的深度最小的半支配点，那么树上路径 $(x, y)$ 中的点不是 $x$ 的支配点: 从 $y$ 出发，存在一条路径不经过这些点到达 $x$。记 $sdom(x)$ 为 $x$ 的深度最小的半支配点。

考虑得到了半支配点后，如何求支配点: 对于一个点 $x$ , 树上路径 $(x, sdom(x))$ 的点不是 $x$ 的支配点。并且对于任意一个 $x$ 的祖先 $y$, 树上路径 $(y, sdom(y))$ 中的点也一定不是 $x$ 的支配点。如果某个 $x$ 的祖先 $z$ 不被 $(x, sdom(x))$ 和任意一个 $(y, sdom(y))$ 包含，那么 $z$ 一定是 $x$ 的支配点。

``` C++

```

# prufer 序列 (待更新)	

# LGV 引理 (待更新)	
Lindström–Gessel–Viennot lemma，即 LGV 引理，可以用来处理有向无环图上不相交路径计数等问题。

# 二分图匹配问题

## 最长反链(待更新)

## 霍尔定理

二分图一侧的子图$V$有完全匹配，当且仅当对$V$的任意子集$A$,和$A$直接相连的点的个数大于等于$A$的点的个数。
如果一个点集$S$满足上述条件,那么它一定是一个完美匹配的子集。
霍尔定理也可以求匹配数:$|V| - max(|A| - T(A))$,$T(A)$是指另一侧中和$A$直接相连的点的个数。

## 最小点覆盖方案构造
对二分图做完最大匹配后，从左侧所有未被匹配的点出发，每次从左往右走一条未被匹配的边，从右往左走一条被匹配的边，沿途打标记。最终选择左边所有未被标记的点，加上右边所有被标记的点，此点集可作为一组最小点覆盖方案。其补集可作为一组最大点独立集方案。

## HopcroftKarp算法(二分图匹配)
```C++
//O(nsqrt(m)) be careful init
const int maxN = 55 * 55;
const int maxM = 55 * 55;
struct HopcroftKarp {
	int vis[maxN], level[maxN], ml[maxN], mr[maxM];
	vector<int> edge[maxN];  
	// constructing edges for left part only

	void init(int n) {
		for (int i = 1; i <= n; ++i) edge[i].clear();
	}

	void add(int u, int v) { edge[u].push_back(v); }

	bool dfs(int u) {
		vis[u] = true;
		for (vector<int>::iterator it = edge[u].begin(); it != edge[u].end();
		     ++it) {
			int v = mr[*it];
			if (v == -1 || (!vis[v] && level[u] < level[v] && dfs(v))) {
				ml[u] = *it;
				mr[*it] = u;
				return true;
			}
		}
		return false;
	}

	int matching(int n) {  // n for left
		memset(vis, 0, sizeof(vis));
		memset(level, 0, sizeof(level));
		memset(ml, -1, sizeof(ml));
		memset(mr, -1, sizeof(mr));
		for (int match = 0;;) {
			queue<int> que;
			for (int i = 1; i <= n; ++i) {
				if (ml[i] == -1) {
					level[i] = 0;
					que.push(i);
				} else
					level[i] = -1;
			}
			while (!que.empty()) {
				int u = que.front();
				que.pop();
				for (vector<int>::iterator it = edge[u].begin();
				     it != edge[u].end(); ++it) {
					int v = mr[*it];
					if (v != -1 && level[v] < 0) {
						level[v] = level[u] + 1;
						que.push(v);
					}
				}
			}
			for (int i = 1; i <= n; ++i) vis[i] = false;
			int d = 0;
			for (int i = 1; i <= n; ++i)
				if (ml[i] == -1 && dfs(i)) ++d;
			if (d == 0) return match;
			match += d;
		}
	}
} HK;
```
